import wildImage from "./assets/wild.jpg";
import freeSpinsImage from "./assets/freespins.jpg";
import Elephant from "./assets/eleph.jpg";
import giraffe from "./assets/jeag.jpg";
import Lion from "./assets/lion.jpg";
import animal from "./assets/animal.jpg";
import letterk from "./assets/letterk.png";
import lettera from "./assets/lettera.png";
import letterq from "./assets/letterq.png";
import number from "./assets/number10.png";
import letterj from "./assets/let.png";

// âœ… Symbols (merged: images + emojis + wild types)
export const SYMBOLS = [
  { key: "ELEPHANT", img: Elephant, emoji: "ðŸ˜" },
  { key: "LION", img: Lion, emoji: "ðŸ¦" },
  { key: "GIRAFFE", img: giraffe, emoji: "ðŸ¦’" },
  { key: "RHINO", img: animal, emoji: "ðŸ¦" },
  { key: "A", img: lettera, emoji: "A" },
  { key: "K", img: letterk, emoji: "K" },
  { key: "Q", img: letterq, emoji: "Q" },
  { key: "J", img: letterj, emoji: "J" },
  { key: "10", img: number, emoji: "10" },

  // Wilds
  { key: "IMAGE1", img: wildImage },      // full overlay
  { key: "WILD_FACE", img: wildImage },   // face part
  { key: "WILD_BODY", img: wildImage },   // body part

  // Scatter
  { key: "IMAGE2", img: freeSpinsImage },
];

// âœ… Constants
export const REELS = 5;
export const ROWS = 4;
export const CELL_SIZE = 150; // keep large cell size from first file
export const LINES = 25;
export const STEPS = [0.01, 0.02, 0.05, 0.1, 0.3, 0.5, 1, 2, 5, 10];

// âœ… Paytable
export const PAYTABLE = {
  ELEPHANT: { 3: 30, 4: 120, 5: 600 },
  LION: { 3: 40, 4: 200, 5: 1000 },
  GIRAFFE: { 3: 20, 4: 40, 5: 200 },
  RHINO: { 3: 15, 4: 30, 5: 100 },
  A: { 3: 10, 4: 15, 5: 50 },
  K: { 3: 5, 4: 10, 5: 40 },
  Q: { 3: 5, 4: 10, 5: 40 },
  J: { 3: 5, 4: 10, 5: 30 },
  10: { 3: 5, 4: 10, 5: 30 },
  IMAGE1: { 5: 2000 }, // 5 wilds line
};

// âœ… Paylines
export const PAYLINES = [
  [0, 0, 0, 0, 0],
  [1, 1, 1, 1, 1],
  [2, 2, 2, 2, 2],
  [3, 3, 3, 3, 3],
  [0, 1, 2, 1, 0],
  [3, 2, 1, 2, 3],
  [0, 0, 1, 0, 0],
  [3, 3, 2, 3, 3],
  [1, 0, 0, 0, 1],
  [2, 3, 3, 3, 2],
  [0, 1, 1, 1, 0],
  [3, 2, 2, 2, 3],
  [1, 2, 3, 2, 1],
  [2, 1, 0, 1, 2],
  [0, 1, 0, 1, 0],
  [3, 2, 3, 2, 3],
  [1, 1, 0, 1, 1],
  [2, 2, 3, 2, 2],
  [0, 0, 3, 0, 0],
  [3, 3, 0, 3, 3],
  [1, 2, 1, 2, 1],
  [2, 1, 2, 1, 2],
  [0, 2, 0, 2, 0],
  [3, 1, 3, 1, 3],
  [0, 3, 0, 3, 0],
];

// --- Helpers
export const isWild = (s) =>
  s && (s.key === "IMAGE1" || s.key === "WILD_FACE" || s.key === "WILD_BODY");

export const randSym = (excludeWild = false) => {
  const pool = excludeWild
    ? SYMBOLS.filter((s) => !isWild(s))
    : SYMBOLS;
  return pool[Math.floor(Math.random() * pool.length)];
};

// --- Wild column distribution (normal spin)
function sampleWildColumns() {
  const x = Math.random();
  if (x < 0.30) return 1;     // 30% â†’ 1 column
  if (x < 0.40) return 2;     // 10% â†’ 2 columns
  return 0;                   // 60% â†’ no wild column
}

function sampleWildSize() {
  const sizes = [1, 2, 4];
  return sizes[Math.floor(Math.random() * sizes.length)];
}

// âœ… Inject wild columns for normal spins
export function injectWilds(baseResult) {
  const result = baseResult.map((row) => row.map((c) => ({ ...c })));

  const wildColCount = sampleWildColumns();
  const shuffledCols = Array.from({ length: REELS }, (_, i) => i).sort(
    () => Math.random() - 0.5
  );
  const chosenCols = shuffledCols.slice(0, wildColCount);

  chosenCols.forEach((col) => {
    const size = sampleWildSize();

    if (size === 4) {
      for (let r = 0; r < ROWS; r++) {
        result[r][col] = { key: "IMAGE1", img: wildImage };
      }
      return;
    }

    // stacked wild parts
    for (let r = 0; r < size; r++) {
      result[r][col] =
        r === 0
          ? { key: "WILD_FACE", img: wildImage }
          : { key: "WILD_BODY", img: wildImage };
    }
  });

  return result;
}

// âœ… Free Spins
export function generateFreeSpinResult() {
  const baseResult = Array.from(
    { length: ROWS },
    () => Array.from({ length: REELS }, () => randSym(true))
  );

  const eligibleReels = [0, 2, 4];
  const rand = Math.random();
  const wildReelsCount = rand < 0.6 ? 1 : rand < 0.9 ? 2 : 3;

  const shuffled = [...eligibleReels].sort(() => Math.random() - 0.5);
  const chosenColumns = shuffled.slice(0, wildReelsCount);

  chosenColumns.forEach((col) => {
    for (let row = 0; row < ROWS; row++) {
      baseResult[row][col] = { key: "IMAGE1", img: wildImage };
    }
  });

  return baseResult;
}

// âœ… Free Spins trigger
export function checkFreeSpins(result) {
  return result.flat().filter((s) => s.key === "IMAGE2").length >= 3 ? 10 : 0;
}

// âœ… Calc win
export function calcWin(result, betPerLine) {
  let win = 0;

  PAYLINES.forEach((line) => {
    const symbolsInLine = line.map((rowIndex, col) => result[rowIndex][col]);

    if (symbolsInLine.every((s) => isWild(s))) {
      win += PAYTABLE.IMAGE1[5] * betPerLine;
      return;
    }

    let base = null;
    let count = 0;
    let wildBuffer = 0;

    for (let col = 0; col < REELS; col++) {
      const sym = symbolsInLine[col];
      if (!base) {
        if (isWild(sym)) {
          wildBuffer++;
        } else if (sym.key !== "IMAGE2") {
          base = sym.key;
          count = 1 + wildBuffer;
          wildBuffer = 0;
        } else break;
      } else {
        if (sym.key === base || isWild(sym)) count++;
        else break;
      }
    }

    if (base && count >= 3) {
      const payouts = PAYTABLE[base];
      if (payouts && payouts[count]) win += payouts[count] * betPerLine;
    }
  });

  return +win.toFixed(2);
}