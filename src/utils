import wildImage from "./assets/wild.jpg";
import freeSpinsImage from "./assets/freespins.jpg";

// âœ… Symbols
export const SYMBOLS = [
  { key: "ELEPHANT", emoji: "ğŸ˜" },
  { key: "LION", emoji: "ğŸ¦" },
  { key: "GIRAFFE", emoji: "ğŸ¦’" },
  { key: "RHINO", emoji: "ğŸ¦œ" },
  { key: "A", emoji: "A" },
  { key: "K", emoji: "K" },
  { key: "Q", emoji: "Q" },
  { key: "J", emoji: "J" },
  { key: "10", emoji: "10" },
  { key: "IMAGE1", img: wildImage }, // Wild
  { key: "IMAGE2", img: freeSpinsImage }, // Free Spins (Scatter)
];

// âœ… Constants
export const REELS = 5;
export const ROWS = 4;
export const CELL_SIZE = 150;
export const LINES = 25;
export const STEPS = [0.01, 0.02, 0.05, 0.1, 0.3, 0.5, 1, 2, 5, 10];

// âœ… Paytable
export const PAYTABLE = {
  ELEPHANT: { 3: 30, 4: 120, 5: 600 },
  LION: { 3: 40, 4: 200, 5: 1000 },
  GIRAFFE: { 3: 20, 4: 40, 5: 200 },
  RHINO: { 3: 15, 4: 30, 5: 100 },
  A: { 3: 10, 4: 15, 5: 50 },
  K: { 3: 5, 4: 10, 5: 40 },
  Q: { 3: 5, 4: 10, 5: 40 },
  J: { 3: 5, 4: 10, 5: 30 },
  10: { 3: 5, 4: 10, 5: 30 },
  IMAGE1: { 5: 2000 }, // Wild: ÙÙ‚Ø· 5 Ø¨Ù†ÙØ³ Ø§Ù„Ø³Ø·Ø±
};

// âœ… Paylines (25 Ø®Ø·)
export const PAYLINES = [
  [0, 0, 0, 0, 0],
  [1, 1, 1, 1, 1],
  [2, 2, 2, 2, 2],
  [3, 3, 3, 3, 3],
  [0, 1, 2, 1, 0],
  [3, 2, 1, 2, 3],
  [0, 0, 1, 0, 0],
  [3, 3, 2, 3, 3],
  [1, 0, 0, 0, 1],
  [2, 3, 3, 3, 2],
  [0, 1, 1, 1, 0],
  [3, 2, 2, 2, 3],
  [1, 2, 3, 2, 1],
  [2, 1, 0, 1, 2],
  [0, 1, 0, 1, 0],
  [3, 2, 3, 2, 3],
  [1, 1, 0, 1, 1],
  [2, 2, 3, 2, 2],
  [0, 0, 3, 0, 0],
  [3, 3, 0, 3, 3],
  [1, 2, 1, 2, 1],
  [2, 1, 2, 1, 2],
  [0, 2, 0, 2, 0],
  [3, 1, 3, 1, 3],
  [0, 3, 0, 3, 0],
];

// âœ… Random symbol (Ù…Ø¹ Ø®ÙŠØ§Ø± Ø§Ø³ØªØ¨Ø¹Ø§Ø¯ Ø§Ù„Ù€ Wild)
export const randSym = (excludeWild = false) => {
  const pool = excludeWild
    ? SYMBOLS.filter((s) => s.key !== "IMAGE1")
    : SYMBOLS;
  return pool[Math.floor(Math.random() * pool.length)];
};

// âœ… Generate Free Spin Result
// âœ… Generate Free Spin Result
export function generateFreeSpinResult() {
  // 1ï¸âƒ£ Ù†ÙˆÙ„Ø¯ Ø§Ù„Ø±Ù…ÙˆØ² Ø§Ù„Ø¹Ø§Ø¯ÙŠØ© Ø¨Ø¯ÙˆÙ† Wild
  const baseResult = Array.from(
    { length: ROWS },
    () => Array.from({ length: REELS }, () => randSym(true)) // exclude wild
  );

  // 2ï¸âƒ£ Ø§Ù„Ø£Ø¹Ù…Ø¯Ø© Ø§Ù„Ù…Ø³Ù…ÙˆØ­ ÙÙŠÙ‡Ø§ Wild (1, 3, 5 â†’ index 0, 2, 4)
  const eligibleReels = [0, 2, 4];

  // 3ï¸âƒ£ Ù†Ø­Ø¯Ø¯ Ø¹Ø¯Ø¯ Ø§Ù„Ø£Ø¹Ù…Ø¯Ø© Ø§Ù„ØªÙŠ Ø³ØªØµØ¨Ø­ Wild (Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Ù†Ø³Ø¨ Ø§Ù„Ø§Ø­ØªÙ…Ø§Ù„Ø§Øª Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©)
  const rand = Math.random();
  let wildReelsCount = 1;

  if (rand < 0.6) {
    wildReelsCount = 1; // 60%
  } else if (rand < 0.9) {
    wildReelsCount = 2; // 30%
  } else {
    wildReelsCount = 3; // 10%
  }

  // 4ï¸âƒ£ Ù†Ø®ØªØ§Ø± Ø§Ù„Ø£Ø¹Ù…Ø¯Ø© Ø§Ù„Ø¹Ø´ÙˆØ§Ø¦ÙŠØ©
  const shuffled = [...eligibleReels].sort(() => Math.random() - 0.5);
  const chosenColumns = shuffled.slice(0, wildReelsCount);

  // 5ï¸âƒ£ Ù†Ù…Ù„Ø£ Ø§Ù„Ø£Ø¹Ù…Ø¯Ø© Ø§Ù„Ù…Ø®ØªØ§Ø±Ø© Ø¨Ø§Ù„Ù€ Wild
  chosenColumns.forEach((col) => {
    for (let row = 0; row < ROWS; row++) {
      baseResult[row][col] = { key: "IMAGE1", img: wildImage };
    }
  });

  return baseResult;
}

// âœ… Check Free Spins Trigger
export function checkFreeSpins(result) {
  let count = 0;
  result.flat().forEach((sym) => {
    if (sym.key === "IMAGE2") count++;
  });
  return count >= 3 ? 10 : 0;
}

// âœ… Calculate Win
export function calcWin(result, betPerLine) {
  let win = 0;

  PAYLINES.forEach((line) => {
    const symbolsInLine = line.map((rowIndex, col) => result[rowIndex][col]);

    // ÙƒÙ„Ù‡Ù… Wilds
    if (symbolsInLine.every((s) => s.key === "IMAGE1")) {
      win += PAYTABLE.IMAGE1[5] * betPerLine;
      return;
    }

    let base = null;
    let count = 0;
    let wildBuffer = 0;

    for (let col = 0; col < REELS; col++) {
      const sym = symbolsInLine[col];

      if (!base) {
        if (sym.key === "IMAGE1") {
          wildBuffer++;
        } else if (sym.key !== "IMAGE2") {
          base = sym.key;
          count = 1 + wildBuffer;
          wildBuffer = 0;
        } else break;
      } else {
        if (sym.key === base || sym.key === "IMAGE1") {
          count++;
        } else break;
      }
    }

    if (base && count >= 3) {
      const payouts = PAYTABLE[base];
      if (payouts && payouts[count]) {
        win += payouts[count] * betPerLine;
      }
    }
  });

  return +win.toFixed(2);
}